[Previous](/docs/page00009.md) | [Next](/docs/page00011.md)

# Understanding Database Models: The `Reading` Model

So far, we've defined Pydantic models which structure our API *responses*. Now, let's look at the SQLAlchemy model in `models.py`, which defines the structure of our database *table*.

```python
# From models.py

from sqlalchemy import Column, Integer, String, Float, DateTime
from database import Base

class Reading(Base):
    __tablename__ = "readings"

    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime, index=True)
    plant_id = Column(String, index=True)
    lettuce_image_url = Column(String)
    ec = Column(Float)
    ph = Column(Float)
    temp_c = Column(Float)
    n_ppm = Column(Float)
    p_ppm = Column(Float)
    k_ppm = Column(Float)
```

### What is this class doing?

This class is an **Object-Relational Mapper (ORM)** model. It creates a mapping between a Python object (`Reading`) and a table in your PostgreSQL database (`readings`).

*   **`class Reading(Base)`**: Defines a Python class that inherits from the `Base` we created in `database.py`. This is how SQLAlchemy knows it's a database model.
*   **`__tablename__ = "readings"`**: Explicitly tells SQLAlchemy that this model corresponds to the `readings` table in the database.
*   **`id = Column(...)`**: Each attribute defines a column in the table. We specify the data type (e.g., `Integer`, `Float`, `DateTime`) and other properties like `primary_key=True` (to uniquely identify each row) and `index=True` (to make lookups on that column faster).

This model is the "source of truth" for your database structure. Alembic reads this class to generate migration scripts, and your application will use it to create, read, update, and delete records in the `readings` table.

[Previous](/docs/page00009.md) | [Next](/docs/page00011.md)