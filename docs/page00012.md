[Previous](/docs/page00011.md) | [Next](/docs/page00013.md)

# Connecting the API to Real Data

Now that our database infrastructure is in place (thanks to SQLAlchemy and Alembic), the next logical step is to "wire up" our FastAPI application to use it. Currently, our endpoints return static "dummy data." We will replace this with dynamic queries that fetch real records from our `readings` table.

## The Plan

1.  **Database Session Dependency**: Create a reusable `get_db` dependency to manage database sessions for each request.
2.  **Ingestion Endpoint**: Create a new `POST` endpoint to allow our sensors (or a simulation script) to upload new readings to the database.
3.  **Update Read Endpoints**: Modify our existing `GET` endpoints (`/latest` and `/history`) to query the database instead of returning hardcoded dictionaries.

### Step 1: Database Session Dependency

In `main.py` (or `database.py` if you prefer to keep it separate), we need a function that yields a database session. FastAPI uses this for **Dependency Injection**.

```python
from database import SessionLocal

# Dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### Step 2: Create an Ingestion Endpoint

We need a way to get data *in* before we can get it *out*. Let's add a `POST` route to `main.py`. This endpoint will receive JSON data matching our Pydantic model and save it as a new row in the `readings` table.

**Proposed Endpoint:** `POST /api/v1/readings`

*   **Input:** JSON payload (EC, pH, Temperature, etc.)
*   **Action:** Create a new `Reading` SQLAlchemy object, add it to the session, commit, and refresh.

### Step 3: Update GET Endpoints

Now we refactor the existing routes.

#### `/api/v1/readings/latest`
*   **Logic:** Query the `readings` table, sort by `timestamp` descending, and take the first result (`.first()`).
*   **Transformation:** Convert the SQLAlchemy object into the Pydantic `LatestReadingResponse` format.

#### `/api/v1/readings/history`
*   **Logic:** Query the `readings` table.
*   **Filtering:** Use the `range` parameter to filter by `timestamp` (e.g., `timestamp >= now - 7 days`).
*   **Transformation:** Convert the list of SQLAlchemy objects into the `HistoryResponse` format.

## Moving Forward

By completing these steps, our API will be fully functional:
1.  Sensors send data -> `POST /api/v1/readings` -> Database
2.  Frontend requests data -> `GET /api/v1/readings/latest` -> Database -> Frontend

[Previous](/docs/page00011.md) | [Next](/docs/page00013.md)
