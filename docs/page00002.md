[Previous](/docs/page00001.md) | [Next](/docs/page00003.md)

# Understanding Pydantic Models: `SensorData`

In `main.py`, you'll find several classes that inherit from `BaseModel`. These are called **Pydantic Models**, and they are one of FastAPI's most powerful features. Let's break down the `SensorData` model as an example.

```python
# From main.py

class SensorData(BaseModel):
    ec: float
    ph: float
    temp_c: float
```

### What is this class doing?

Think of this class as a blueprint or a contract for a piece of your data. It defines the exact structure and data types for your sensor readings.

1.  **`class SensorData(BaseModel):`**
    *   This defines a Python class named `SensorData`.
    *   It inherits from `BaseModel`, which comes from the Pydantic library. This inheritance gives the class special "superpowers" for data validation, serialization (converting to/from JSON), and generating documentation automatically.

2.  **The Attributes (`ec`, `ph`, `temp_c`)**
    *   Inside the class, we define the fields we expect our sensor data object to have.
    *   `ec`: Stands for **Electrical Conductivity**, a common measurement in hydroponics to gauge nutrient levels.
    *   `ph`: Represents the **pH level** of the water.
    *   `temp_c`: Represents the water **temperature in Celsius**.

3.  **The Type Hints (`: float`)**
    *   This is the core of Pydantic's validation. The `: float` annotation tells Pydantic that the value for `ec`, `ph`, and `temp_c` **must** be a floating-point number (e.g., `6.4`, `25.1`).
    *   When FastAPI receives a request or sends a response using this model, it automatically checks the data. If an incoming request had `"ph": "six"`, Pydantic would reject it with a clear error. This ensures your API is robust and only processes valid data.

### How It's Used

This model isn't used alone. It's a building block for larger models. If you look at the `LatestReadingResponse` model in `main.py`, you'll see it contains `sensors: SensorData`. This means the `sensors` field in your final JSON response *must* conform to the structure we defined in the `SensorData` class.

In short, Pydantic models are reusable, self-validating building blocks that help you create robust and well-documented APIs by enforcing a strict structure on your data.

[Previous](/docs/page00001.md) | [Next](/docs/page00003.md)