[Previous](/docs/page00012.md) | [Next](/docs/page00014.md)

# API Connected to Database

This document outlines the changes made to connect the FastAPI application to the PostgreSQL database. We have transitioned from using static "dummy data" to persisting and retrieving real data via SQLAlchemy.

## Changes Implemented

### 1. Database Dependency
In `main.py`, we imported `SessionLocal` from `database.py` (via the `get_db` helper) and `Session` from SQLAlchemy. This allows us to inject a database session into our route handlers using FastAPI's `Depends`.

```python
from database import get_db
from sqlalchemy.orm import Session
```

### 2. New Input Model
We defined a Pydantic model `ReadingCreate` to validate the data sent to our new ingestion endpoint. This ensures that the client sends all necessary fields (sensor data + predictions) with the correct data types.

```python
class ReadingCreate(BaseModel):
    timestamp: datetime
    plant_id: str
    # ... other fields
```

### 3. Ingestion Endpoint (`POST /api/v1/readings`)
We created a new endpoint to save sensor readings.
- **Method:** POST
- **Input:** JSON body matching `ReadingCreate`
- **Action:** Creates a new `Reading` record in the database.

### 4. Updated Latest Reading Endpoint (`GET /api/v1/readings/latest`)
This endpoint now queries the database for the most recent record based on `timestamp`.
- **Logic:** `db.query(Reading).order_by(desc(Reading.timestamp)).first()`
- **Response Construction:** The raw database record is mapped to the complex nested JSON structure (`LatestReadingResponse`) required by the frontend.
- **Status Logic:** We added basic logic to determine `low/ok/high` status for nutrients dynamically, replacing the hardcoded values.

### 5. Updated History Endpoint (`GET /api/v1/readings/history`)
This endpoint now filters records based on the requested time range.
- **Logic:** Calculates a cutoff date (e.g., `now - 7 days`) and filters: `Reading.timestamp >= cutoff`.
- **Response:** Returns a list of data points formatted for charting.

## Next Steps
With the backend fully wired up, we can now focus on:
- **Testing:** Verifying the endpoints with tools like Postman or curl.
- **Frontend Integration:** Updating the frontend application to call these real API endpoints.
- **IoT Integration:** Configuring the physical sensors to POST data to `/api/v1/readings`.

[Previous](/docs/page00012.md) | [Next](/docs/page00014.md)